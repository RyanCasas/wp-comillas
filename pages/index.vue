<template>
  <div class="relative flex items-top justify-center min-h-screen bg-gray-100 sm:items-center sm:pt-0">
    <div class="max-w-6xl mx-auto sm:px-6 lg:px-8">
      <h1 class="text-2xl leading-7 font-semibold flex justify-center pt-8 sm:pt-0">
        «Comillas»
      </h1>

      <div class="mt-8 bg-white overflow-hidden shadow sm:rounded-lg p-6">
        <div class="pt-4 columns-1 md:columns-2">
          <div>
            <h3 class="pb-2">Texto "original"</h3>
            <textarea cols="50" rows="8"
            class="block bg-white w-full border border-slate-300 rounded-md p-4 placeholder:italic placeholder:text-slate-400"
            v-model="data"></textarea>
            <div class="pt-4" v-html="data" />
          </div>
          
          <div>
            <h3 class="pb-2">Texto «al español»</h3>
            <textarea readonly cols="50" rows="8"
              onclick="this.focus();this.select()"
              class="block bg-white w-full border border-slate-300 rounded-md p-4 placeholder:italic placeholder:text-slate-400"
              v-model="dataProcessed" />
            <div class="pt-4" v-html="dataProcessed" />
          </div>
        </div>
      </div>

      <h2 class="text-center py-8">
        Por Ryan Casas
      </h2>
    </div>
  </div>
</template>

<script>
// We declare these in the global scope since the app isn't going to be anything fancy
const parser = new DOMParser();

// The function to swap quotation marks
const spanishify = (content) => {
  let i = 0;
  let open = true;
  let newContent = "";

  // Some browsers complain about the properties being readonly
  // so we read them character by character
  for(let i = 0; i < content.length; i++){
    // If the character is a quotation mark
    if(content[i] === '"' || content[i] === "'"){
      // We alternate between open and close
      newContent += open?"«":"»";
      open = !open;
    }else{
      // If it isn't, just copy it
      newContent += content[i];
    }
  }

  return newContent;
};

// The recursive processor
const processor = (childNodes) => {
  let text = '';

  // We go through all the child nodes
  childNodes.forEach(node => {

    if(node.nodeName === '#text'){
      // If it is a text node, it's time to Spanishify it
      text += spanishify(node.nodeValue);
    }else{
      // Otherwise we check if there are more nodes inside the node
      if(node.firstChild !== null){
        // If there are, repeat this process recursively
        node.innerHTML = processor(node.childNodes);
      }

      // At last, we return the whole element, with the innerHTML already changed
      text += node.outerHTML;
    }
  });

  return text;
};

export default {
  data(){
    return {
      // Example data
      data: `'Esto' es una "prueba" de las comillas para <a href="https://es.wordpress.org">"WordPress.org"</a> que respeta enlaces y todo lo que "no debería ser entrecomillado", como los enlaces o las <span style="color:#09f"><b>"propiedades embebidas"</b> en las etiquetas HTML</span>.`,
    }
  },
  
  computed: {
    dataProcessed(){
      // We retrieve the data from the textarea and parse it through the DOMParser
      const dom = parser.parseFromString(this.data, 'text/html');

      // We then process the <body> tag generated by the DOMParser,
      // which contains our original data
      return processor(dom.querySelector('body').childNodes);
    },
  },
}
</script>